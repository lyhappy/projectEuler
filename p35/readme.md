## 朴素想法
找出所有素数，挨个检查每个素数的rotation number是否为素数，计数。

## 优化点

1. 因为有大量判断是否为素数的运算，所以可以采用素数表来判定。
2. 素数表可以使用 **[埃拉托斯特尼筛法](https://zh.wikipedia.org/wiki/埃拉托斯特尼筛法)** 生成。
3. 使用素数表相当于用空间复杂度替换时间复杂度，素数表可以使用位图索引节省存储空间。
4. 经查资料得知，素数位于<img src="https://latex.codecogs.com/gif.latex?$6n\pm1$"/>的位置, 所以遍历检查时，步长可以设置为6
5. 含有偶数数字和数字5的素数，不可能其所有rotation number均为素数，所以在做rotation的过程，可以率先排除这些数字。
6. 由5可知，组成满足条件的素数必然是数字1，3，7，9的排列组合。所以也可以先依次计算出所有的候选数集。(未实现)

## 优化点6的补充
1. 在有空间限制时，可以考虑方法6. 简单算一下候选数集需要的存储空间：
<img src="https://latex.codecogs.com/gif.latex?\begin{equation} 4 + 4^2 + 4^3 + 4^4 + 4^5 + 4^6 = 5460 \end{equation}" />

嗯~ 可以有效缩小存储空间, 不需要素数表了

## $6n\pm1$
其实很容易理解。
* 因为6n不会是素数，能被6整除嘛！
* 6n + 2和6n + 4也不会是素数，能被2整除
* 6n + 3也不会是素数，能被3整除
* 6n + 5和6n - 1是同一个序列
所以所有的素数必然是6n的左邻右舍
